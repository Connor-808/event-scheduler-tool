import { createClient } from '@supabase/supabase-js';

// Supabase client configuration
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

// Create Supabase client for client-side usage
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// TypeScript Types based on SCHEMA.md

/**
 * Event entity - represents a schedulable event
 */
export interface Event {
  event_id: string; // Primary key, generated by unique-names-generator
  title: string; // Event name/description
  location: string | null; // Optional place name or address
  location_details: Record<string, unknown> | null; // Additional location metadata (JSON)
  locked_time_id: string | null; // Foreign key to TimeSlot when locked
  status: 'active' | 'locked' | 'cancelled'; // Event status
  created_at: string; // ISO timestamp
  ttl: string | null; // Time-to-live for automatic cleanup
}

/**
 * TimeSlot entity - represents a proposed meeting time
 */
export interface TimeSlot {
  timeslot_id: string; // UUID primary key
  event_id: string; // Foreign key to Event
  start_time: string; // ISO timestamp
  end_time: string | null; // Optional end time
  label: string | null; // Human-readable label (e.g., "Saturday Morning")
  created_at: string; // ISO timestamp
}

/**
 * UserCookie entity - tracks anonymous participants via browser cookies
 */
export interface UserCookie {
  cookie_id: string; // UUID stored in browser cookie
  event_id: string; // Foreign key to Event
  display_name: string | null; // Optional user-provided name
  is_organizer: boolean; // First cookie for event = organizer
  created_at: string; // ISO timestamp
  last_active: string; // ISO timestamp
}

/**
 * Vote entity - records participant availability for time slots
 */
export interface Vote {
  vote_id: string; // UUID primary key
  timeslot_id: string; // Foreign key to TimeSlot
  cookie_id: string; // Foreign key to UserCookie
  availability: 'available' | 'maybe' | 'unavailable'; // User's availability
  created_at: string; // ISO timestamp
  updated_at: string; // ISO timestamp
}

/**
 * Extended types for queries with aggregated data
 */

export interface TimeSlotWithVotes extends TimeSlot {
  votes: Vote[];
  available_count: number;
  maybe_count: number;
  unavailable_count: number;
}

export interface EventWithDetails extends Event {
  time_slots: TimeSlot[];
  participants: UserCookie[];
  locked_time?: TimeSlot;
}

/**
 * Type for vote submission
 */
export interface VoteSubmission {
  timeslot_id: string;
  availability: 'available' | 'maybe' | 'unavailable';
}

/**
 * Database helper functions
 */

/**
 * Get event with all related data
 */
export async function getEventWithDetails(eventId: string): Promise<EventWithDetails | null> {
  const { data: event, error: eventError } = await supabase
    .from('events')
    .select('*')
    .eq('event_id', eventId)
    .single();

  if (eventError || !event) return null;

  const { data: timeSlots } = await supabase
    .from('time_slots')
    .select('*')
    .eq('event_id', eventId)
    .order('start_time', { ascending: true });

  const { data: participants } = await supabase
    .from('user_cookies')
    .select('*')
    .eq('event_id', eventId);

  let lockedTime = undefined;
  if (event.locked_time_id) {
    const { data: locked } = await supabase
      .from('time_slots')
      .select('*')
      .eq('timeslot_id', event.locked_time_id)
      .single();
    lockedTime = locked || undefined;
  }

  return {
    ...event,
    time_slots: timeSlots || [],
    participants: participants || [],
    locked_time: lockedTime,
  };
}

/**
 * Get vote breakdown for dashboard
 */
export async function getVoteBreakdown(eventId: string): Promise<TimeSlotWithVotes[]> {
  const { data: timeSlots } = await supabase
    .from('time_slots')
    .select('*')
    .eq('event_id', eventId)
    .order('start_time', { ascending: true });

  if (!timeSlots) return [];

  const slotsWithVotes = await Promise.all(
    timeSlots.map(async (slot) => {
      const { data: votes } = await supabase
        .from('votes')
        .select('*')
        .eq('timeslot_id', slot.timeslot_id);

      const votesList = votes || [];
      return {
        ...slot,
        votes: votesList,
        available_count: votesList.filter((v) => v.availability === 'available').length,
        maybe_count: votesList.filter((v) => v.availability === 'maybe').length,
        unavailable_count: votesList.filter((v) => v.availability === 'unavailable').length,
      };
    })
  );

  // Sort by most available votes first
  return slotsWithVotes.sort((a, b) => {
    if (b.available_count !== a.available_count) {
      return b.available_count - a.available_count;
    }
    return a.unavailable_count - b.unavailable_count;
  });
}

/**
 * Get recommended time slot (most available votes)
 */
export async function getRecommendedTime(eventId: string): Promise<TimeSlotWithVotes | null> {
  const breakdown = await getVoteBreakdown(eventId);
  return breakdown.length > 0 ? breakdown[0] : null;
}

/**
 * Upsert votes (insert or update)
 */
export async function upsertVotes(
  cookieId: string,
  votes: VoteSubmission[]
): Promise<{ success: boolean; error?: string }> {
  try {
    const upsertPromises = votes.map((vote) =>
      supabase.from('votes').upsert(
        {
          timeslot_id: vote.timeslot_id,
          cookie_id: cookieId,
          availability: vote.availability,
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: 'timeslot_id,cookie_id',
        }
      )
    );

    await Promise.all(upsertPromises);
    return { success: true };
  } catch (error) {
    return { success: false, error: String(error) };
  }
}

/**
 * Check if event exists
 */
export async function eventExists(eventId: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('events')
    .select('event_id')
    .eq('event_id', eventId)
    .single();

  return !error && !!data;
}

