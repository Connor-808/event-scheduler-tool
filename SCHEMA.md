# Event Scheduler - Database Schema & Entity Relationship Diagram

## Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│                              EVENTS (Parent Entity)                         │
│  ┌───────────────────────────────────────────────────────────────────┐    │
│  │  event_id              TEXT        PRIMARY KEY                     │    │
│  │  title                 TEXT        NOT NULL                        │    │
│  │  location              TEXT        NULLABLE                        │    │
│  │  location_details      JSONB       NULLABLE                        │    │
│  │  locked_time_id        UUID        FOREIGN KEY → time_slots       │    │
│  │  status                TEXT        NOT NULL DEFAULT 'active'       │    │
│  │  created_at            TIMESTAMPTZ DEFAULT NOW()                   │    │
│  │  ttl                   TIMESTAMPTZ NULLABLE                        │    │
│  └───────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                    │                                    │
                    │ 1                                  │ 1
                    │                                    │
        ┌───────────┴──────────┐            ┌───────────┴──────────┐
        │                      │            │                      │
        │ has many             │            │ has many             │
        ▼ *                    │            ▼ *                    │
┌────────────────────┐         │    ┌────────────────────┐        │
│   TIME_SLOTS       │         │    │   USER_COOKIES     │        │
├────────────────────┤         │    ├────────────────────┤        │
│ timeslot_id   UUID │ PK      │    │ cookie_id     UUID │ PK (1) │
│ event_id      TEXT │ FK ─────┘    │ event_id      TEXT │ FK/PK (2)
│ start_time    TS   │              │ display_name  TEXT │
│ end_time      TS   │              │ is_organizer  BOOL │
│ label         TEXT │              │ created_at    TS   │
│ created_at    TS   │              │ last_active   TS   │
└────────────────────┘              │ PK: (cookie_id, event_id)
        │                           └────────────────────┘
        │ 1                                  │ 1
        │                                    │
        │ receives                           │ submits
        │                                    │
        │ *                                  │ *
        │            ┌────────────────────┐  │
        └───────────►│      VOTES         │◄─┘
                     ├────────────────────┤
                     │ vote_id       UUID │ PK
                     │ timeslot_id   UUID │ FK → time_slots
                     │ cookie_id     UUID │ FK (composite)
                     │ event_id      TEXT │ FK (composite)
                     │ availability  TEXT │ CHECK: available|maybe|unavailable
                     │ created_at    TS   │
                     │ updated_at    TS   │
                     │ UNIQUE(timeslot_id, cookie_id) │
                     │ FK: (cookie_id, event_id) → user_cookies │
                     └────────────────────┘
```

## Detailed Schema Definitions

### 1. EVENTS Table

**Purpose**: Stores core event information and serves as parent entity for all related data.

**Schema**:
```sql
CREATE TABLE events (
  -- Primary identifier (human-readable, generated by unique-names-generator)
  event_id TEXT PRIMARY KEY,
  
  -- Event details
  title TEXT NOT NULL,
  location TEXT,
  location_details JSONB, -- Store structured location data (lat/lng, place_id, etc.)
  
  -- Event state
  locked_time_id UUID REFERENCES time_slots(timeslot_id), -- Selected final time
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'locked', 'cancelled')),
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ttl TIMESTAMPTZ -- Time to live - for automatic cleanup
);

-- Indexes for performance
CREATE INDEX idx_events_status ON events(status);
CREATE INDEX idx_events_created_at ON events(created_at);
CREATE INDEX idx_events_ttl ON events(ttl) WHERE ttl IS NOT NULL;
```

**Field Notes**:
- `event_id`: Generated using unique-names-generator (e.g., "brave-blue-elephant")
- `location_details`: JSON structure for future integration with maps/weather
- `locked_time_id`: NULL until organizer locks in a time
- `status`: Enum constraint ensures data integrity
- `ttl`: Optional expiration date for automatic event cleanup (e.g., 90 days after creation)

**Example Record**:
```json
{
  "event_id": "brave-blue-elephant",
  "title": "Weekend Brunch Plans",
  "location": "Downtown Area",
  "location_details": {
    "place_id": "ChIJ...",
    "formatted_address": "123 Main St, City, State"
  },
  "locked_time_id": null,
  "status": "active",
  "created_at": "2025-10-08T14:30:00Z",
  "ttl": "2026-01-08T14:30:00Z"
}
```

---

### 2. TIME_SLOTS Table

**Purpose**: Stores proposed meeting times for each event.

**Schema**:
```sql
CREATE TABLE time_slots (
  -- Primary identifier
  timeslot_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Parent relationship
  event_id TEXT NOT NULL REFERENCES events(event_id) ON DELETE CASCADE,
  
  -- Time information
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ, -- Optional end time
  label TEXT, -- Human-readable label (e.g., "Saturday Morning", "This Weekend")
  
  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_time_slots_event ON time_slots(event_id);
CREATE INDEX idx_time_slots_start_time ON time_slots(start_time);
```

**Field Notes**:
- `timeslot_id`: UUID for internal referencing
- `event_id`: Foreign key with CASCADE delete (when event deleted, time slots deleted)
- `start_time`: Required datetime for the proposed meeting
- `end_time`: Optional for open-ended gatherings
- `label`: Display label for preset options (e.g., "This Weekend - Saturday 10am")

**Example Records**:
```json
[
  {
    "timeslot_id": "550e8400-e29b-41d4-a716-446655440000",
    "event_id": "brave-blue-elephant",
    "start_time": "2025-10-12T10:00:00Z",
    "end_time": "2025-10-12T12:00:00Z",
    "label": "Saturday Morning",
    "created_at": "2025-10-08T14:30:00Z"
  },
  {
    "timeslot_id": "550e8400-e29b-41d4-a716-446655440001",
    "event_id": "brave-blue-elephant",
    "start_time": "2025-10-12T14:00:00Z",
    "end_time": null,
    "label": "Saturday Afternoon",
    "created_at": "2025-10-08T14:30:00Z"
  }
]
```

---

### 3. USER_COOKIES Table

**Purpose**: Tracks anonymous participants via browser cookies without requiring authentication.

**Schema**:
```sql
CREATE TABLE user_cookies (
  -- Composite primary key (cookie can participate in multiple events)
  cookie_id UUID NOT NULL,
  event_id TEXT NOT NULL REFERENCES events(event_id) ON DELETE CASCADE,
  
  -- User information (optional)
  display_name TEXT, -- User can optionally provide name
  is_organizer BOOLEAN NOT NULL DEFAULT FALSE, -- First cookie for event = organizer
  
  -- Activity tracking
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_active TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Composite primary key
  PRIMARY KEY (cookie_id, event_id)
);

-- Indexes for performance
CREATE INDEX idx_user_cookies_event ON user_cookies(event_id);
CREATE INDEX idx_user_cookies_organizer ON user_cookies(event_id, is_organizer) WHERE is_organizer = TRUE;
CREATE UNIQUE INDEX idx_one_organizer_per_event ON user_cookies(event_id) WHERE is_organizer = TRUE;
```

**Field Notes**:
- `cookie_id`: UUID stored in browser cookie, persists across sessions
- `event_id`: A cookie can participate in multiple events (create multiple records)
- `display_name`: Optional user-provided name (defaults to "Anonymous")
- `is_organizer`: First cookie to create event gets organizer privileges
- `last_active`: Updated on each interaction for engagement tracking

**Example Records**:
```json
[
  {
    "cookie_id": "660e8400-e29b-41d4-a716-446655440000",
    "event_id": "brave-blue-elephant",
    "display_name": "Sarah",
    "is_organizer": true,
    "created_at": "2025-10-08T14:30:00Z",
    "last_active": "2025-10-08T15:45:00Z"
  },
  {
    "cookie_id": "770e8400-e29b-41d4-a716-446655440000",
    "event_id": "brave-blue-elephant",
    "display_name": null,
    "is_organizer": false,
    "created_at": "2025-10-08T16:20:00Z",
    "last_active": "2025-10-08T16:22:00Z"
  }
]
```

---

### 4. VOTES Table

**Purpose**: Records participant availability for each time slot.

**Schema**:
```sql
CREATE TABLE votes (
  -- Primary identifier
  vote_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Relationships
  timeslot_id UUID NOT NULL REFERENCES time_slots(timeslot_id) ON DELETE CASCADE,
  cookie_id UUID NOT NULL,
  event_id TEXT NOT NULL,
  
  -- Vote data
  availability TEXT NOT NULL CHECK (availability IN ('available', 'maybe', 'unavailable')),
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  UNIQUE(timeslot_id, cookie_id), -- One vote per user per time slot
  FOREIGN KEY (cookie_id, event_id) REFERENCES user_cookies(cookie_id, event_id) ON DELETE CASCADE,
  FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_votes_timeslot ON votes(timeslot_id);
CREATE INDEX idx_votes_cookie ON votes(cookie_id);
CREATE INDEX idx_votes_composite ON votes(timeslot_id, cookie_id);
CREATE INDEX idx_votes_availability ON votes(availability);

-- Trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_votes_updated_at BEFORE UPDATE ON votes
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**Field Notes**:
- `vote_id`: UUID for internal referencing
- `timeslot_id`: Which time slot this vote is for
- `cookie_id`: Which user submitted this vote
- `availability`: Three states for flexible responses
- `UNIQUE constraint`: Prevents duplicate votes, allows updates via UPSERT
- Trigger automatically updates `updated_at` on vote changes

**Availability States**:
- `available`: User can definitely make it
- `maybe`: User might be able to make it
- `unavailable`: User cannot make it

**Example Records**:
```json
[
  {
    "vote_id": "880e8400-e29b-41d4-a716-446655440000",
    "timeslot_id": "550e8400-e29b-41d4-a716-446655440000",
    "cookie_id": "660e8400-e29b-41d4-a716-446655440000",
    "availability": "available",
    "created_at": "2025-10-08T14:35:00Z",
    "updated_at": "2025-10-08T14:35:00Z"
  },
  {
    "vote_id": "880e8400-e29b-41d4-a716-446655440001",
    "timeslot_id": "550e8400-e29b-41d4-a716-446655440000",
    "cookie_id": "770e8400-e29b-41d4-a716-446655440000",
    "availability": "maybe",
    "created_at": "2025-10-08T16:22:00Z",
    "updated_at": "2025-10-08T16:22:00Z"
  }
]
```

---

## Relationship Cardinality Summary

```
EVENT (1) ────────── (*) TIME_SLOT
  │                        │
  │                        │
  │                        │ (1)
  │ (1)                    │
  │                        │
  │                   (*) VOTE
  │                        │
  │                        │ (*)
  │                        │
  └─── (*) USER_COOKIE ────┘
```

**Relationship Rules**:
1. **Event → Time Slots**: One-to-Many (1:*)
   - Each event has multiple proposed time slots
   - Each time slot belongs to exactly one event
   - Cascade delete: removing event removes all its time slots

2. **Event → User Cookies**: One-to-Many (1:*)
   - Each event has multiple participants (cookies)
   - Each cookie participates in one event per record
   - Note: Same cookie can participate in multiple events (separate records)
   - Cascade delete: removing event removes all participant records

3. **Time Slot → Votes**: One-to-Many (1:*)
   - Each time slot receives multiple votes (one per participant)
   - Each vote is for exactly one time slot
   - Cascade delete: removing time slot removes all its votes

4. **User Cookie → Votes**: One-to-Many (1:*)
   - Each participant (cookie) can vote on multiple time slots
   - Each vote belongs to exactly one participant
   - Cascade delete: removing cookie removes all their votes

5. **Event → Locked Time**: One-to-One (1:0..1)
   - Each event can have zero or one locked time
   - The locked time must be one of the event's proposed time slots
   - Self-referential relationship via `locked_time_id` foreign key

---

## Query Examples

### Get Event with All Data
```sql
SELECT 
  e.*,
  json_agg(DISTINCT jsonb_build_object(
    'timeslot_id', ts.timeslot_id,
    'start_time', ts.start_time,
    'end_time', ts.end_time,
    'label', ts.label
  )) as time_slots,
  json_agg(DISTINCT jsonb_build_object(
    'cookie_id', uc.cookie_id,
    'display_name', COALESCE(uc.display_name, 'Anonymous'),
    'is_organizer', uc.is_organizer
  )) as participants
FROM events e
LEFT JOIN time_slots ts ON e.event_id = ts.event_id
LEFT JOIN user_cookies uc ON e.event_id = uc.event_id
WHERE e.event_id = 'brave-blue-elephant'
GROUP BY e.event_id;
```

### Get Vote Breakdown for Dashboard
```sql
SELECT 
  ts.timeslot_id,
  ts.start_time,
  ts.label,
  COUNT(v.vote_id) FILTER (WHERE v.availability = 'available') as available_count,
  COUNT(v.vote_id) FILTER (WHERE v.availability = 'maybe') as maybe_count,
  COUNT(v.vote_id) FILTER (WHERE v.availability = 'unavailable') as unavailable_count,
  json_agg(jsonb_build_object(
    'display_name', COALESCE(uc.display_name, 'Anonymous'),
    'availability', v.availability
  )) as voter_details
FROM time_slots ts
LEFT JOIN votes v ON ts.timeslot_id = v.timeslot_id
LEFT JOIN user_cookies uc ON v.cookie_id = uc.cookie_id
WHERE ts.event_id = 'brave-blue-elephant'
GROUP BY ts.timeslot_id, ts.start_time, ts.label
ORDER BY available_count DESC, maybe_count DESC;
```

### Recommend Best Time Slot
```sql
SELECT 
  ts.timeslot_id,
  ts.start_time,
  ts.label,
  COUNT(v.vote_id) FILTER (WHERE v.availability = 'available') as available_count,
  COUNT(v.vote_id) FILTER (WHERE v.availability = 'unavailable') as unavailable_count
FROM time_slots ts
LEFT JOIN votes v ON ts.timeslot_id = v.timeslot_id
WHERE ts.event_id = 'brave-blue-elephant'
GROUP BY ts.timeslot_id
ORDER BY 
  available_count DESC,
  unavailable_count ASC
LIMIT 1;
```

### Upsert Vote (Insert or Update)
```sql
INSERT INTO votes (timeslot_id, cookie_id, availability)
VALUES ($1, $2, $3)
ON CONFLICT (timeslot_id, cookie_id)
DO UPDATE SET 
  availability = EXCLUDED.availability,
  updated_at = NOW()
RETURNING *;
```

---

## Supabase-Specific Considerations

### Row Level Security (RLS) Policies

```sql
-- Enable RLS on all tables
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
ALTER TABLE time_slots ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_cookies ENABLE ROW LEVEL SECURITY;
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;

-- Events: Anyone can read, no authentication required
CREATE POLICY "Events are publicly readable"
ON events FOR SELECT
TO public
USING (true);

-- Time slots: Anyone can read
CREATE POLICY "Time slots are publicly readable"
ON time_slots FOR SELECT
TO public
USING (true);

-- User cookies: Anyone can read
CREATE POLICY "User cookies are publicly readable"
ON user_cookies FOR SELECT
TO public
USING (true);

-- Votes: Anyone can read
CREATE POLICY "Votes are publicly readable"
ON votes FOR SELECT
TO public
USING (true);

-- Insert/Update policies can be handled via service role key in API routes
```

### Real-Time Subscriptions

Enable real-time for live updates:
```sql
-- Enable real-time on votes table for live updates
ALTER PUBLICATION supabase_realtime ADD TABLE votes;
ALTER PUBLICATION supabase_realtime ADD TABLE user_cookies;
```

**Client-side subscription example**:
```javascript
const votesSubscription = supabase
  .channel('event-votes')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'votes',
      filter: `timeslot_id=in.(${timeslotIds.join(',')})`
    },
    (payload) => {
      // Update UI with new vote data
      handleVoteUpdate(payload);
    }
  )
  .subscribe();
```

---

## Data Migration & Cleanup

### TTL Cleanup Function
```sql
-- Function to clean up expired events
CREATE OR REPLACE FUNCTION cleanup_expired_events()
RETURNS void AS $$
BEGIN
  DELETE FROM events
  WHERE ttl IS NOT NULL 
  AND ttl < NOW();
END;
$$ LANGUAGE plpgsql;

-- Schedule via pg_cron or external scheduler
-- Example: Run daily at 3am
-- SELECT cron.schedule('cleanup-events', '0 3 * * *', 'SELECT cleanup_expired_events()');
```

### Statistics View for Analytics
```sql
CREATE VIEW event_statistics AS
SELECT 
  e.event_id,
  e.title,
  e.status,
  e.created_at,
  COUNT(DISTINCT uc.cookie_id) as participant_count,
  COUNT(DISTINCT ts.timeslot_id) as timeslot_count,
  COUNT(DISTINCT v.vote_id) as total_votes,
  COUNT(DISTINCT v.vote_id) FILTER (WHERE v.availability = 'available') as available_votes,
  CASE 
    WHEN e.locked_time_id IS NOT NULL THEN TRUE
    ELSE FALSE
  END as is_finalized
FROM events e
LEFT JOIN user_cookies uc ON e.event_id = uc.event_id
LEFT JOIN time_slots ts ON e.event_id = ts.event_id
LEFT JOIN votes v ON ts.timeslot_id = v.timeslot_id
GROUP BY e.event_id;
```

---

## Performance Optimization Notes

1. **Indexes**: All critical foreign keys and frequently queried columns are indexed
2. **Cascade Deletes**: Automatic cleanup of related records when parent is deleted
3. **UNIQUE Constraints**: Prevent duplicate votes, enable efficient UPSERT operations
4. **JSONB**: Use for flexible location data without schema changes
5. **Partial Indexes**: For TTL and organizer queries to reduce index size
6. **Connection Pooling**: Configure Supabase connection pooler for high concurrency

---

## Schema Version Control

**Initial Version**: 1.0  
**Created**: 2025-10-08  
**Database**: PostgreSQL 15+ (via Supabase)  
**Extensions Required**: 
- `uuid-ossp` (for UUID generation)
- `pg_cron` (optional, for scheduled cleanup)